-- Stream Exclusive ELUA File Template (Version 2 File Pointers)


--[[
Setting code up for loading 2nd LUA file when reading CMD.
Necessary for acquiring Info Pointer and PalNo dependent file reading.
The jump target from CMD file reading is the instruction after jmp Stream.exe+3555E
Reading CMD (before push) ESP +0x14 is Character Info Pointer 

mugen.exe+358CA - 80 7C 24 30 00        - cmp byte ptr [esp+30],00
>>> mugen.exe+358CF - 0F84 32FEFFFF         - je mugen.exe+35707
<<< mugen.exe+358D5 - 8B CE                 - mov ecx,esi
mugen.exe+358D7 - 51                    - push ecx
mugen.exe+358D8 - 68 806A4F00           - push mugen.exe+F6A80

Backup registers, don't bother to XOR them this time
Next we lookup our custom file path, find the two null terminators
Add the "2" for loading StreamElua2<null>.
Afterwards same procedure for calling LUA file
When finished, restore registers and jump back to CMD processing.
JMP START > 4358CF
JMP ENDED > 43585D

This time we are going to load a BIN file into a memory region and jump to that.
The reason is in File 2 it will be easier to disable the jump.
This does have a cost of allocating memory for each character but not a big deal.

--]]




-- DO NOT RENAME THIS FILE.
local EXPLOIT_FILENAME = "StreamElua"

-- path to the library for C interface - you can move or rename this, but make sure not to   include the `.lua` extension in this constant.
local EXPLOIT_LIBRARY = "Supernull/MLL/mll"

-- location of the payload DLL files - feel free to modify + rename these, however, it may not load unless you leave the DLL extension intact
local EXPLOIT_FFILIB = "Supernull/Libraries/ffi.dll"
local EXPLOIT_LUALIB = "Supernull/Libraries/lua5.1.dll"

-- location of a folder containing any functions we will be memory-mapping and using
local EXPLOIT_FUNCTION_FOLDER = "Supernull/Functions/"


function bootstrap()  

  mugen.log("Executing Initial File\n")

  -- get folder containing this elua file
  local sourcefile = debug.getinfo(1, "S").source
  local sourcefolder = string.sub(sourcefile, 2, string.len(sourcefile) - string.len(EXPLOIT_FILENAME))
  -- 1.1b1 restricts package.path to be `data/?.lua`, but we can just add another load path here
  package.path = package.path .. ";./?.lua;./?"

  -- attempt to load mll.lua -- we load this into the global table for use later
  _G.mll = require(sourcefolder .. EXPLOIT_LIBRARY)
  mll.LoadBaseLibraries(sourcefolder, EXPLOIT_LUALIB, EXPLOIT_FFILIB)

  if not mll.VirtualProtect(0x400000, 0x100000, 0x40)
    then
      mugen.log("Failed to execute Virtual Protect on 0x400000")
      os.exit(-1)
    end
  mugen.log("Successfully granted execute permissions in main memory regions.\n\n")

  local sourcefile = debug.getinfo(1, "S").source
  mugen.log("Test" .. sourcefile .. "\n")
  local sourcefolder = string.sub(sourcefile, 2, string.len(sourcefile) - string.len(EXPLOIT_FILENAME))

  -- attempt to load mll.lua -- we load this into the global table for use later
  _G.mll = require(sourcefolder .. EXPLOIT_LIBRARY)
  mll.LoadBaseLibraries(sourcefolder, EXPLOIT_LUALIB, EXPLOIT_FFILIB)

  StreamElua2Address = mll.MemoryMapFile(sourcefolder .. "LoadLua11A4.bin", 0x2000, 0x40)
  JumpDistance = StreamElua2Address - 0x004358CF - 5
  mll.WriteByte(0x004358CF, 0xE9)
  mll.WriteInteger(0x004358D0, JumpDistance)
  mugen.log("Finished first step\n\n")
  
end

-- hacky thing to gather the full stack trace on crash in a submodule
-- (this is only really needed here because stuff can crash oddly during load, especially ffi-related pieces)
local co = coroutine.create(bootstrap)
local status, err = coroutine.resume(co)
if not status then
    mugen.log("Failed to run bootstrap script: " .. err .. "\n")
    local full_tb = debug.traceback(co)
    mugen.log(full_tb .. "\n")
end